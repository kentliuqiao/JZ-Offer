package topic1

/*

题目：
在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

解法分析：
解法1：
先将输入的数组排序，然后从头到尾扫描排序后的数组即可。时间复杂度由排序决定，最好为O(nlongn)
解法2：
采用哈希表。从头到尾扫描数组，对于每个元素都可以用O(1)的时间来判断哈希表中是否已经包含了该数字。如果没有，则将其加入表中；否则就找到了重复的数字。时间复杂度为O(n)，但是同时也需要一个大小为O(n)的哈希表，故空间复杂度为O(n)，因此是用了空间换时间的思想
解法3：
考虑到数组中的数字在0~n-1之间，那么如果无重复的数字，且有序排列，则索引位置i处存储的数字m必然和i相等。利用这个特性，我们可以重排数组。从头到尾一次遍历数组，每遍历到一个数字m，就和其当前的索引值i比较，会有两种结果，若m=i，则接着遍历下一个位置；若m!=i，则比较m和数组在索引m处的数字，若相等，则找到了一个重复的数字，直接返回结果，若不等，则交换m和索引m处的数字。重复以上过程，直到找到一个重复的数字。时间复杂度为O(n)，空间复杂度为O(1)。
解法4:
同样考虑到数组中的数字在0~n-1范围之间，可以考虑使用原数组设置标志。从头到尾遍历数组，在访问索引位置为i值为m的元素时，查看数组索引位置在m处的值是否大于n-1，如果不大于，则加上n，之后再访问到相同的数字时，那么就会发现此时的值已经大于n-1，那么就找到了重复数字。时间复杂度为O(n)，空间复杂度为O(1)。但是该解法有一个缺点，在作加法时有可能溢出。

*/

// Solution3 ...
func Solution3(num []int) int {
	if len(num) == 0 {
		return -1
	}
	for _, m := range num {
		if m < 0 || m > len(num)-1 {
			return -1
		}
	}
	for i, m := range num {
		if i == m {
			continue
		}
		if m == num[m] {
			return m
		}
		num[i], num[m] = num[m], num[i]
	}

	return -1
}

// Solution4 ...
func Solution4(num []int) int {
	if len(num) == 0 {
		return -1
	}
	for _, m := range num {
		if m < 0 || m > len(num)-1 {
			return -1
		}
	}

	for _, m := range num {
		if m >= len(num) {
			m -= len(num)
		}
		if num[m] >= len(num) {
			return m
		}
		num[m] += len(num)
	}
	return -1
}
